# Redis

##  Redis 

 Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘 上进行保存。 

 因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。  

 Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限 制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。 比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高 性能的 tag 系统等等。 

 另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能 读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。 

##  Redis 与 memcached 相比 

1. memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类 
2.  redis 的速度比 memcached 快很多 
3.  .redis 可以持久化其数据 

##  Redis 数据类型

 String、List、Set、Sorted Set、hashes 

##  Redis 数据淘汰策略 

1.  noeviction: 不删除任意数据(但redis还会根据引用计数器进行释放),这时如果内存不够时，会直接返回错误。 
2.  allkeys-lru:  从数据集中(包括设置过期时间以及未设置过期时间的数据集中)，选择最近最久未使用的数据释放；  
3.  volatile-lru:  从设置了过期时间的数据集中，选择最近最久未使用的数据释放；   
4.  allkeys-random:  从数据集中(包括了设置过期时间以及未设置过期时间)随机选择一个数据进行入释放； 
5.  volatile-random:  从设置了过期时间的数据集中，随机选择一个数据进行释放； 
6.  volatile-ttl:  从设置了过期时间的数据集中，选择马上就要过期的数据进行释放操作； 

##   redis 的持久化 

 RDB(Redis DataBase:在不同的时间点将 redis 的数据生成的快照同步到磁盘等介质上):内存 到硬盘的快照，定期更新。缺点：耗时，耗性能(fork+io 操作)，易丢失数据。 

 AOF(Append Only File：将 redis 所执行过的所有指令都记录下来，在下次 redis 重启时，只 需要执行指令就可以了):写日志。缺点：体积大，恢复速度慢。  

 bgsave 做镜像全量持久化，aof 做增量持久化。因为 bgsave 会消耗比较长的时间，不够实 时，在停机的时候会导致大量的数据丢失，需要 aof 来配合，在 redis 实例重启时，优先使 用 aof 来恢复内存的状态，如果没有 aof 日志，就会使用 rdb 文件来恢复。Redis 会定期做 aof 重写，压缩 aof 文件日志大小。Redis4.0 之后有了混合持久化的功能，将 bgsave 的全量 和 aof 的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。bgsave 的 原理，fork 和 cow, fork 是指 redis 通过创建子进程来进行 bgsave 操作，cow 指的是 copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据 会逐渐和子进程分离开来。  

## 为什么 Redis 需要把所有数据放到内存中 

 Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。 所以 redis 具有快速和数据持久化的特征，如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的 性能。  

 在内存越来越便宜的今天，redis 将会越来越受欢迎， 如果设置了最大使用的内存，则数据已有记录数达 到内存限值后不能继续插入新值。  

##  Redis 三种集群模式

### 主从复制

####  **主从复制原理：** 

- 从服务器连接主服务器，发送SYNC命令； 
- 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 
- 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 
- 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 
- 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 
- 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；（**从服务器初始化完成**）
- 主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（**从服务器初始化完成后的操作**）

####  **主从复制优缺点：** 

#####  **优点：** 

- 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离
- 为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成
- Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。
- Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。
- Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据

#####  **缺点：** 

- Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
- 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

### 哨兵模式

 当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。 为此，Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。 

 哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。 

 	1）监控主服务器和从服务器是否正常运行。 
  （2）主服务器出现故障时自动将从服务器转换为主服务器。 

####  **哨兵的工作方式：** 

- 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
- 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）
- 如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态
- 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）
- 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。
- 当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
- 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

####  **哨兵模式的优缺点** 

#####  **优点：** 

- 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
- 主从可以自动切换，系统更健壮，可用性更高。

##### 缺点：

  Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。 

###  Redis-Cluster集群

 redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。 

  Redis-Cluster采用无中心结构,它的特点如下： 

- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
- 节点的fail是通过集群中超过半数的节点检测失效时才生效。
- 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。

####  **工作方式：** 

 在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。 

 为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。 

##  MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据 

 redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 比如（allkeys-lru）

##  Redis 适合的场景

###  （1）会话缓存（Session Cache） 

 最常用的一种使用 Redis 的情景是会话缓存（sessioncache），用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的 购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 

 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为 人知的商业平台 Magento 也提供 Redis 的插件。 

###  （2）全页缓存（FPC）  

 除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实 例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。  

 再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。 

此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快 速度加载你曾浏览过的页面。  

###  （3）队列 

 Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列 平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。  

 如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的 就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看 

###  （4）排行榜/计数器 

 Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（SortedSet）也使 得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。 

 所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像 下面一样执行即可： 

 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执 行：  

```
ZRANGE user_scores 0 10 WITHSCORES
```

 Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可 以在这里看到。 

###  （5）发布/订阅 

 最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见 人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建 立聊天系统！ 

##  Redis 支持的 Java 客户端 

 Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。  

##  Redis 和 Redisson 有什么关系 

 Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对 象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。 

##  Jedis 与 Redisson 对比有什么优缺点 

 Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；  

 Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作， 不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从 而让使用者能够将精力更集中地放在处理业务逻辑上。  

##  Redis 哈希槽

 Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通 过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。 

##  Redis 集群的主从复制模型 

  为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型, 每个节点都会有 N-1 个复制品.   

##  Redis 集群会有写操作丢失吗 

 Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 

##  Redis 集群之间是如何复制的 

 异步复制 

##  Redis 集群最大节点个数是多少 

 16384 个 

##  Redis 集群如何选择数据库 

 Redis 集群目前无法做数据库选择，默认在 0 数据库 

##  Redis 中的管道 

 一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。  

 这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功 能，大大加快了从服务器下载新邮件的过程。 

##  Redis 事务 

 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。  

 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 

事务相关命令： MULTI、EXEC、DISCARD、WATCH 

##  Redis key 的过期时间和永久有效分别怎么设置 

 EXPIRE 和 PERSIST 命令 

##  Redis 如何做内存优化 

 尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该 尽可能的将你的数据模型抽象到一个散列表里面。 比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是 应该把这个用户的所有信息存储到一张散列表里面。  

##  Redis 回收进程 

 一个客户端运行了新的命令，添加了新的数据。  

 Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。 

 一个新的命令被执行，等等。 

 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。 

 如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限 制就会被这个内存使用量超越。 

##  Redis 分布式锁 

 先拿 setnx 来争抢锁，并设置超时时间，抢到之后，业务执行完成后释放锁。 

##  Redis 做异步队列 

 一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。  

 缺点： 

 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。 

 使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。  

##  缓存穿透 

 一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统查找（比如 DB）。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。这就叫 做缓存穿透。  

###  如何避免缓存穿透 

 1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理 缓存。  

 2：对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过 该 bitmap 过滤。  

##  缓存击穿 

 对于设置了过期时间的 key，缓存在某个时间点过期的时候，恰好这时间点对 这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并 回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。 

### 如何避免缓存击穿

 1.使用互斥锁：当缓存失效时，不立即去 load db，先使用如 Redis 的 setnx 去设 置一个互斥锁，当操作成功返回时再进行 load db 的操作并回设缓存，否则重试 get 缓存的 方法。 

 2.永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新）。 

##  缓存雪崩 

 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压 力。导致系统崩溃。 

 **与缓存击穿的区别：雪崩是很多 key，击穿是某一个 key 缓存。** 

###  如何避免缓存雪崩 

 1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。  

 2：做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为 短期，A2 设置为长期 

 3：不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀 

##  redis 和 memcached 什么区别 

1. mc 可缓存图片和视频。rd 支持除 k/v 更多的数据结构; 
2. rd 可以使用虚拟内存，rd 可持久化和 aof 灾难恢复，rd 通过主从支持数据备份; 
3. rd 可以做消息队列。  

##  为什么高并发下有时单线程的 redis 比多线程的 memcached 效率要高 

 mc 多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。  

##  使用 redis 如何设计分布式锁 

1. 线程 A setnx(上锁的对象,超时时的时间戳 t1)，如果返回 true，获得锁。 
2. 线程 B 用 get 获取 t1,与当前时间戳比较,判断是是否超时,没超时 false,若超时执行第 3 步; 
3. 计算新的超时时间 t2,使用 getset 命令返回 t3(该值可能其他线程已经修改过),如果 t1==t3，获得锁，如果 t1!=t3 说明锁被其他线程获取了。 
4. 获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时， 不用处理（防止删除其他线程的锁）。  

##  使用 zk 如何设计分布式锁

1. 客户端对某个方法加锁时，在 zk 上的与该方法对应的指定节点的目录下，生成一个唯一 的瞬时有序节点 node1; 
2. 客户端获取该路径下所有已经创建的子节点，如果发现自己创建的 node1 的序号是最小 的，就认为这个客户端获得了锁。 
3. 如果发现 node1 不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。
4. .获取锁后，处理完逻辑，删除自己创建的 node1 即可。 
5. 区别:zk 性能差一些，开销大，实现简单。  

##  redis 过期策略 

###  定时过期

 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。 

###  惰性过期

 只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。 

###  定期过期

每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)

 **Redis中同时使用了惰性过期和定期过期两种过期策略。** 

##   java 代码实现LRU算法

 1.通过双向链表来实现，新数据插入到链表头部；2.每当缓存命中（即缓存 数据被访问），则将数据移到链表头部；3.当链表满的时候，将链表尾部的数据丢弃。 

 LinkedHashMap：HashMap 和双向链表合二为一即是 LinkedHashMap。HashMap 是无序 的，LinkedHashMap 通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插 入顺序（默认），也可以是访问顺序。  

## Redis还是 Memcached 

 选择 redis 的情况 :

 1、复杂数据结构，value 的数据是哈希，列表，集合，有序集合等这种情况下，会选择 redis, 因为 memcache 无法满足这些数据结构，最典型的的使用场景是，用户订单列表， 用户消息，帖子评论等。  

 2、需要进行数据的持久化功能，但是注意，不要把 redis 当成数据库使用，如果 redis 挂了，内存能够快速恢复热数据，不会将压力瞬间压在数据库上，没有 cache 预热的过 程。对于只读和数据一致性要求不高的场景可以采用持久化存储 

 3、高可用，redis 支持集群，可以实现主动复制，读写分离，而对于 memcache 如果想 要实现高可用，需要进行二次开发。  

 4、存储的内容比较大，memcache 存储的 value 最大为 1M。 

 选择 memcache 的场景：  

 1、纯 KV,数据量非常大的业务，使用 memcache 更合适，原因是， 

 a)memcache 的内存分配采用的是预分配内存池的管理方式，能够省去内存分配的时 间，redis 是临时申请空间，可能导致碎片化。  

 b)虚拟内存使用，memcache 将所有的数据存储在物理内存里，redis 有自己的 vm 机 制，理论上能够存储比物理内存更多的数据，当数据超量时，引发 swap,把冷数据刷新到 磁盘上，从这点上，数据量大时，memcache 更快 

 c)网络模型，memcache 使用非阻塞的 IO 复用模型，redis 也是使用非阻塞的 IO 复用 模型，但是 redis 还提供了一些非 KV 存储之外的排序，聚合功能，复杂的 CPU 计算，会阻 塞整个 IO 调度，从这点上由于 redis 提供的功能较多，memcache 更快些 

 d) 线程模型，memcache 使用多线程，主线程监听，worker 子线程接受请求，执行 读写，这个过程可能存在锁冲突。redis 使用的单线程，虽然无锁冲突，但是难以利用多核 的特性提升吞吐量。 

##  Redis 常见的性能问题和解决方案 

 1、master 最好不要做持久化工作，如 RDB 内存快照和 AOF 日志文件 

 2、如果数据比较重要，某个 slave 开启 AOF 备份，策略设置成每秒同步一次 

 3、为了主从复制的速度和连接的稳定性，master 和 Slave 最好在一个局域网内 

 4、尽量避免在压力大得主库上增加从库 

 5、主从复制不要采用网状结构，尽量是线性结构，Master<--Slave1<----Slave2 .... 

##  Redis 当中有哪些数据结构

 字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。如果是高级用户，那 么还会有，如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、 Geo、Pub/Sub。 

##  假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如 果将它们全部找出来？ 

 使用 keys 指令可以扫出指定模式的 key 列表。 

  redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一 段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指 令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客 户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。 

##  Redis 做异步队列 

 使用 list 类型保存数据信息，rpush 生产消息，lpop 消费消息，当 lpop 没有消息时，可 以 sleep 一段时间，然后再检查有没有信息，如果不想 sleep 的话，可以使用 blpop, 在没 有信息的时候，会一直阻塞，直到信息的到来。redis 可以通过 pub/sub 主题订阅模式实现 一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。  

##  Redis 如何实现延时队列 

 使用 sortedset，使用时间戳做 score, 消息内容作为 key,调用 zadd 来生产消息，消费者 使用 zrangbyscore 获取 n 秒之前的数据做轮询处理。 

